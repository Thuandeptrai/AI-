# -*- coding: utf-8 -*-
"""HMM+LSTM.ipynb

Automatically generated by Colaboratory.

Original file is located at
https://colab.research.google.com/drive/1vtSA5qdaOD8A25H8bxR9TZC7DJMp6LFk
"""
from pickle import TRUE

import tensorflow
import threading
import os
##os.add_dll_directory(
##"C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.5/bin")
import math
import matplotlib.pyplot as plt
from tensorflow import keras 
import pandas as pd
import numpy as np
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
from keras.layers import *
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
from sklearn.model_selection import train_test_split
from keras.callbacks import EarlyStopping
from hmmlearn import hmm
import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore
import uuid

import sys

cred = credentials.Certificate({
"type": "service_account",
"project_id": "testpro-58820",
"private_key_id": "1d2b2a851a40417d04d66b37d4a26111ce27a8ab",
"private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCoj4rWmt4vOeTR\nS4pHy5n7kmTg1xXK62HCyWCLyBXm2mHaTan2gfL+HHyr3UAuWhbm3Zk0TRVv2fLm\ndXjaeJ817B5lcbM+dXd7BzVHX6vc4mcEQTTJS9qbJfluKd7r6O9QP4DHaOD55cDq\nzXjBv6Yb0+fDhC8ewRdhTuucaQhF4k9v/JN9D+j84ucj8FVnUyS7rbw2H9MfIQwp\nlX1+oFganescNDztUrw3bmbUC1g8YLXj4+W74Eb6k1FPq8OlJ6WejgFV47nqF1Tv\nLLicLfcITfvgEPCQdsKKv2rbsEg0FNypWrVbTZ8R0o/y1zGVLe30TaFnX7eYTfIK\nLKrF1pH9AgMBAAECggEAAXpuyoaFq87ba514uzv1IABu64zfV038p79p3hf1Xzar\nlIVJWAzYM3PPARfZ4/4sxL4NRajmZvp3l59QncPgi5HES3n1izbvAxBzXmqfoHqI\n0j/7JUfJxUIOP7HUz2dVz/OansUT8gUajcSbCkHyxDw1xGBwpFmnqZYOWWsPZEN9\n6Y+rHB5MwlWug/HDhUiKBh84zyabPcjzlxwp4GN86Q2euXQazb0GoqPZFrfgYQEZ\nLCnZOsxTo4nc9Y9FfG02OgeHKQoFY0DT6hd26YkRnZ6RasQ8fRFQ4x5WYIB9ufK1\npHIhwriAM6zDG+nYvi04Hfzy4LvQXlPZSMlkMYAYUQKBgQDowE48WtKU6lP/OSRK\ncrPeTzG1W3BkZfIWJLg3kmP4S3MyvOK/Lh0I+CjhSYOyM+FoA1WVcP77uHLAd5n2\ntrx4+sSKEMasCPGws5SOWXZju0NdIwBeOyjSqxDw4B9nuJdwMmXdXOUYWbw2m9WC\nugxrxOhMIKVXSiUa6joxzWLPbQKBgQC5ZdFzn6m6rgh1Y++UdIo0M5XHqZ3GhIn9\n5cuS9KXNsjOdueyaNjXeJ8iX4oOYuVXp4IvpVlMDYmssU64CEdof8xFtN+Shhb3l\nvnzhxR6e6L3+PdTiXzDIX2oboInCjjnK0pbFISUxO7jorxs5etPgTBhytBo0l447\nnbKQoCHi0QKBgQCunhgUD8+NCYCbKjOf5w4q6x9QAJoBuLo3ArVye9GkpnZ2yl8T\nL3V5FTUWUCENwP6LGnVK+MtT7r2oyBIqlk4wNXLeYlerGcq51wDNCzFXAVc4uNm9\n2IR4CP9ct8jX+BUlh6oEuXznF+uszJ0SxqIq+D+PXa6uHmJYHwIp+vz2wQKBgF4c\npXpALnSpK3oLxO5jSlS9aubz3zeKyFGueOycbB5Cu5jxbH3LzwR6xYT0Y0D/s/EJ\nH3zPaUxqhWT3BXnffg6B4PLEULb9oSwiyloBKk4Yb3nEAXD4SVctuDtV/xhYAlZH\nGGnxLWQUoQTc/sDq7OsLNc3kRvkzhewVXTO1Vf5BAoGAIDHle8pYnfhqplJ/6h2n\nkh0e97kFGiNPg1HqjbfbC9LFpJlcnJo7dzo3A4dHsUH/pV6IgKTTA/tAIOCrqBAU\nnjbXbNXWL0CUsEcWmH41XP93LHrFv358f0+G1I7uGAcjvhqMwKoZc/7fp2gqrN05\nAt4Q7yBpHqNkBy3xVLREjMY=\n-----END PRIVATE KEY-----\n",
"client_email": "firebase-adminsdk-yszn9@testpro-58820.iam.gserviceaccount.com",
"client_id": "106126062831895793999",
"auth_uri": "https://accounts.google.com/o/oauth2/auth",
"token_uri": "https://oauth2.googleapis.com/token",
"auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
"client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-yszn9%40testpro-58820.iam.gserviceaccount.com"
}
)


firebase_admin.initialize_app(cred)

# Commented out IPython magic to ensure Python compatibility.


# Use a service account




db = firestore.client()

users = list(db.collection(u'data').stream())
users_dict = list(map(lambda x: x.to_dict(), users))
data = pd.DataFrame(users_dict, columns=[
                    "Date", "Open", "High", "Low", "Close", "Adj Close", "Volume", "Change"])

data.head(10)

full_len = data.shape[0]
num_val = 360
num_test = 180
num_subtract = 500
num_train = full_len - num_subtract - num_val - num_test
print('Data length = ', full_len - num_subtract)
print('Num train = ', num_train, " Num test = ",
    num_test, " Num validation = ", num_val)

print(data.iloc[500:, :])

market_data = data.iloc[:, 1:5].values
print(market_data)

log_market_data = market_data

plt.figure(figsize=(30, 13))
plt.plot(list(range(full_len)), market_data[:, 3])
plt.title('Close price')
plt.figure(figsize=(30, 13))
for i in range(4):
    plt.plot(list(range(full_len)), log_market_data[:, i])
plt.title('Close price after log')

MA_data = log_market_data[500:, 3]
MA5 = []
MA20 = []
MA50 = []
MA100 = []
for i in range(500, full_len):
    MA5.append(np.mean(log_market_data[i-5:i, 0]))
    MA20.append(np.mean(log_market_data[i-20:i, 0]))
    MA50.append(np.mean(log_market_data[i-50:i, 0]))
    MA100.append(np.mean(log_market_data[i-100:i, 0]))

plt.figure(figsize=(30, 13))
plt.plot(list(range(full_len - num_subtract)), MA_data, label="Close price")
plt.plot(list(range(full_len - num_subtract)), MA5, label="MA5")
plt.plot(list(range(full_len - num_subtract)), MA20, label="MA20")
plt.plot(list(range(full_len - num_subtract)), MA50, label="MA50")
plt.plot(list(range(full_len - num_subtract)), MA100, label="MA100")
plt.rcParams.update({'font.size': 42})
plt.legend(fontsize=28)

volum_change = data.iloc[500:, 6:8].values
print(volum_change)


def std(X):
    avg = np.mean(X)
    sum = 0
    for i in range(len(X)):
        sum = sum + (X[i] - avg)**2
    return math.sqrt(sum/(len(X)-1))


STD5 = []
STD20 = []
STD50 = []
STD100 = []
for i in range(500, full_len):
    STD5.append(std(log_market_data[i-5:i, 0]))
    STD20.append(std(log_market_data[i-20:i, 0]))
    STD50.append(std(log_market_data[i-50:i, 0]))
    STD100.append(std(log_market_data[i-100:i, 0]))

plt.figure(figsize=(30, 13))
plt.plot(list(range(full_len - num_subtract)), MA_data, label="Close price")
plt.plot(list(range(full_len - num_subtract)), STD5, label="STD5")
plt.plot(list(range(full_len - num_subtract)), STD20, label="STD20")
plt.plot(list(range(full_len - num_subtract)), STD50, label="STD50")
plt.plot(list(range(full_len - num_subtract)), STD100, label="STD100")
plt.legend(fontsize=28)


def calculate_ema(prices, days, smoothing=2):
    ema = [sum(prices[:days]) / days]
    for price in prices[days:]:
        ema.append((price * (smoothing / (1 + days))) +
                ema[-1] * (1 - (smoothing / (1 + days))))
    return ema


EMA5 = calculate_ema(log_market_data[500-4:, 0], 5)
EMA20 = calculate_ema(log_market_data[500-19:, 0], 20)
EMA50 = calculate_ema(log_market_data[500-49:, 0], 50)
EMA100 = calculate_ema(log_market_data[500-99:, 0], 100)

plt.figure(figsize=(30, 13))
plt.plot(list(range(full_len - 500)), MA_data, label='Close price')
plt.plot(list(range(full_len - 500)), EMA5, label='EMA5')
plt.plot(list(range(full_len - 500)), EMA20, label='EMA20')
plt.plot(list(range(full_len - 500)), EMA50, label='EMA50')
plt.plot(list(range(full_len - 500)), EMA100, label='EMA100')

plt.legend(fontsize=28)

MACD0 = np.array(EMA5) - np.array(EMA20)
MACD1 = np.array(EMA5) - np.array(EMA50)
MACD2 = np.array(EMA5) - np.array(EMA100)
MACD3 = np.array(EMA20) - np.array(EMA50)
MACD4 = np.array(EMA20) - np.array(EMA100)
MACD5 = np.array(EMA50) - np.array(EMA100)
plt.figure(figsize=(30, 13))
plt.plot(list(range(full_len - 500)), MACD0, label='MACD0')
plt.plot(list(range(full_len - 500)), MACD1, label='MACD1')
plt.plot(list(range(full_len - 500)), MACD2, label='MACD2')
plt.plot(list(range(full_len - 500)), MACD3, label='MACD3')
plt.plot(list(range(full_len - 500)), MACD4, label='MACD4')
plt.plot(list(range(full_len - 500)), MACD5, label='MACD5')
plt.legend(fontsize=28)

band_up = np.array(MA20) + 2*np.array(STD20)
band_low = np.array(MA20) - 2*np.array(STD20)

plt.figure(figsize=(30, 13))
plt.plot(list(range(full_len - 500)), MA_data, label='Close Price')
plt.plot(list(range(full_len - 500)), band_up, label='Band_upper')
plt.plot(list(range(full_len - 500)), band_low, label='Band_lower')
plt.legend(fontsize=28)

log_close_price = np.log(log_market_data[500:, 0])
plt.figure(figsize=(30, 8))
plt.plot(list(range(full_len - 500)), log_close_price)

# Using HMM to predict optimal sequence of hidden state

likelihood_vect = np.empty([0, 1])
aic_vect = np.empty([0, 1])
bic_vect = np.empty([0, 1])
STATE_SPACE = range(2, 20)
NUM_ITERS = 10000
dataset = MA_data[num_val:num_val+num_train]
dataset = np.reshape(dataset, (-1, 1))

for states in STATE_SPACE:
    num_params = states**2 + states
    dirichlet_params_states = np.random.randint(1, 50, states)
    #model = hmm.GaussianHMM(n_components=states, covariance_type='full', startprob_prior=dirichlet_params_states, transmat_prior=dirichlet_params_states, tol=0.0001, n_iter=NUM_ITERS, init_params='mc')
    model = hmm.GaussianHMM(
        n_components=states, covariance_type='full', tol=0.0001, n_iter=NUM_ITERS)
    model.fit(dataset)

    if model.monitor_.iter == NUM_ITERS:
        print('Increase number of iterations')
        sys.exit(1)
    likelihood_vect = np.vstack((likelihood_vect, model.score(dataset)))
    aic_vect = np.vstack(
        (aic_vect, -2 * model.score(dataset) + 2 * num_params))
    bic_vect = np.vstack(
        (bic_vect, -2 * model.score(dataset) + num_params * np.log(dataset.shape[0])))

opt_states = np.argmin(bic_vect) + 2
print('Optimum number of states are {}'.format(opt_states))

plt.figure(figsize=(30, 13))
plt.plot(STATE_SPACE, bic_vect, label="BIC")
plt.legend(fontsize=28)


model = hmm.GaussianHMM(n_components=opt_states,
                        covariance_type='full', n_iter=1000)
model.fit(np.reshape(MA_data, (-1, 1)))

range_color = ['brown', 'red', 'deeppink', 'violet', 'aqua', 'gold', 'blue',
            'orangered', 'purple', 'lawngreen', 'dodgerblue', 'lightcoral', 'lime', 'black']
hid_state = model.predict(np.reshape(
    MA_data, (-1, 1)), full_len - num_subtract)
state_color = list(range(num_train+num_val))
for i in range(num_val+num_train):
    state_color[i] = range_color[hid_state[i]]
    # print(range_color[hid_state[i]])

print(hid_state)

plt.figure(figsize=(30, 13))
x_range = list(range(num_train+num_val))
# print(x_range)
plt.scatter(x_range, MA_data[:num_val+num_train], color=state_color)
# plt.scatter([1,5,3],[5,15,35], color = ['aqua','navy','violet'])

plt.figure(figsize=(30, 8))
plt.plot(hid_state)

#hid_state = hid_state.reshape(-1,1)
print(hid_state.shape)
#hid_state = sc.fit_transform(hid_state)

X = np.random.rand(full_len - num_subtract, 9)
# ------------Market Data----------
X[:, 0] = log_market_data[500:, 3]
X[:, 1:4] = log_market_data[500:, 0:3]
X[:, 4:6] = volum_change
X[:, 6] = log_market_data[500:, 1] - log_market_data[500:, 2]
X[:, 7] = hid_state

# Technical Indicator Feature
# -----Moving Average-------------
# X[:,8] = MA5
# X[:,9] = MA20
# X[:,10] = MA50
# X[:,11] = MA100
# --------Standard Deviation------
# X[:,12] = STD5
# X[:,13] = STD20
# X[:,14] = STD50
# X[:,15] = STD100
# -------Exponential Moving Average---
# X[:,16] = EMA5
# X[:,17] = EMA20
# X[:,18] = EMA50
# X[:,19] = EMA100
# ------------Moving Average Covergence Divergence--------
X[:, 8] = MACD1
# X[:,21] = MACD1
# X[:,22] = MACD2
# X[:,23] = MACD3
# X[:,24] = MACD4
# X[:,25] = MACD5
# ---------Boillinger Bands-----------------
# X[:,26] = band_up
# X[:,27] = band_low
# ---------Log Close Price----------
# X[:,13] = log_close_price

plt.figure(figsize=(30, 13))
plt.plot(volum_change[:, 0])

a = band_low
print("Min = ", np.amin(a))
print("Max = ", np.amax(a))
print("Mean = ", np.mean(a))
print("Std = ", np.std(a))

print(a)

sc = MinMaxScaler(feature_range=(0, 1))
sc_prc = MinMaxScaler(feature_range=(0, 1))

X[:, 0:1] = sc_prc.fit_transform(X[:, 0:1])
X[:, 1:] = sc.fit_transform(X[:, 1:])

X_train = X[num_val:num_val+num_train, :]
X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
y_train = X[num_val+1:num_val+num_train + 1, 0:1]

X_val = X[:num_val, :]
X_val = np.reshape(X_val, (X_val.shape[0], X_val.shape[1], 1))
y_val = X[1:num_val+1, 0:1]

X_test = X[num_val+num_train:num_val+num_train+num_test, :]
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
y_test = sc_prc.inverse_transform(X[:, 0:1])[num_val+num_train:]

LSTM_model = Sequential()
# Adding the first LSTM layer and some Dropout regularisation
LSTM_model.add(LSTM(units=50, return_sequences=True,
            input_shape=(X_train.shape[1], 1)))
LSTM_model.add(Dropout(0.2))
# Adding a second LSTM layer and some Dropout regularisation
LSTM_model.add(LSTM(units=50, return_sequences=True))
LSTM_model.add(Dropout(0.2))
# Adding a third LSTM layer and some Dropout regularisation
LSTM_model.add(LSTM(units=50, return_sequences=True))
LSTM_model.add(Dropout(0.2))
# Adding a fourth LSTM layer and some Dropout regularisation
LSTM_model.add(LSTM(units=50))
LSTM_model.add(Dropout(0.2))
# Adding the output layer
LSTM_model.add(Dense(units=1))
# Compiling the RNN
LSTM_model.compile(optimizer='adam', loss='mean_squared_error')

LSTM_model.summary()

LSTM_model.fit(X_train, y_train, epochs=1, batch_size=100,
            validation_data=(X_val, y_val))

LSTM_model.save('HMM_LSTM_final.h5')

LSTM_model.load_weights('HMM_LSTM_final.h5')

X_total = X[:full_len - 201, :]
X_total = np.reshape(X_total, (X_total.shape[0], X_total.shape[1], 1))

predict_price = LSTM_model.predict(X_test)
print(predict_price.shape)
predict_price = sc_prc.inverse_transform(predict_price)

# predict_price = sc.inverse_transform(predict_price)

# predict_price = np.exp(predict_price)
# real_price = np.exp(y_test)
# real_price = sc_prc.inverse_transform(y_train)

real_price = y_test

print(predict_price)

print('predict ', predict_price.shape[0], 'real ', real_price.shape[0])

plt.figure(figsize=(30, 13))
plt.plot(list(range(180)), predict_price, 'r', label='Predict Price')
plt.plot(list(range(180)), real_price, 'b--', label='Real Price')
plt.legend()

MAPE = np.abs(predict_price - real_price)
RMSE = np.multiply(MAPE, MAPE)
RMSE = math.sqrt(np.mean(RMSE))/np.mean(real_price)
MAE = np.mean(MAPE)/np.mean(real_price)
MAPE = np.divide(MAPE, real_price)
MAPE = np.mean(MAPE)
doctId = str(uuid.uuid4())


outputData = db.collection(u'Output').document(doctId)

data = {
    u'MAPE': MAPE,
    u'MAE': MAE*100,
    u'RMSE': RMSE*100,
}

outputData.set(data)

print('MAPE = ', MAPE)
print('MAE = ', MAE*100, '%')
print('RMSE = ', RMSE*100, '%')
# Create an Event for notifying main thread.
callback_done = threading.Event()

# Create a callback on_snapshot function to capture changes

